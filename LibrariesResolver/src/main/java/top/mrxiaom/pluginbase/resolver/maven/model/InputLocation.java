// =================== DO NOT EDIT THIS FILE ====================
// Generated by Modello 2.1.2,
// any modifications will be overwritten.
// ==============================================================

package top.mrxiaom.pluginbase.resolver.maven.model;

/**
 * Class InputLocation.
 * 
 * @version $Revision$ $Date$
 */
public final class InputLocation
    implements java.io.Serializable, java.lang.Cloneable, InputLocationTracker
{

      //--------------------------/
     //- Class/Member Variables -/
    //--------------------------/

    /**
     * The one-based line number. The value will be non-positive if
     * unknown.
     */
    private int lineNumber;

    /**
     * The one-based column number. The value will be non-positive
     * if unknown.
     */
    private int columnNumber;

    /**
     * Field source.
     */
    private InputSource source;

    /**
     * Field locations.
     */
    private java.util.Map<Object, InputLocation> locations;

    /**
     * Field location.
     */
    private InputLocation location;


      //----------------/
     //- Constructors -/
    //----------------/

    public InputLocation(int lineNumber, int columnNumber)
    {
        this.lineNumber = lineNumber;
        this.columnNumber = columnNumber;
    } //-- org.apache.maven.model.InputLocation(int, int)

    public InputLocation(int lineNumber, int columnNumber, InputSource source)
    {
        this.lineNumber = lineNumber;
        this.columnNumber = columnNumber;
        this.source = source;
    } //-- org.apache.maven.model.InputLocation(int, int, InputSource)


      //-----------/
     //- Methods -/
    //-----------/

    /**
     * Method clone.
     * 
     * @return InputLocation
     */
    public InputLocation clone()
    {
        try
        {
            InputLocation copy = (InputLocation) super.clone();

            if ( copy.locations != null )
            {
                copy.locations = new java.util.LinkedHashMap<>( copy.locations );
            }

            return copy;
        }
        catch ( java.lang.Exception ex )
        {
            throw new UnsupportedOperationException( getClass().getName()
                + " does not support clone()", ex);
        }
    } //-- InputLocation clone()

    /**
     * Get the one-based column number. The value will be
     * non-positive if unknown.
     * 
     * @return int
     */
    public int getColumnNumber()
    {
        return this.columnNumber;
    } //-- int getColumnNumber()

    /**
     * Get the one-based line number. The value will be
     * non-positive if unknown.
     * 
     * @return int
     */
    public int getLineNumber()
    {
        return this.lineNumber;
    } //-- int getLineNumber()

    /**
     * 
     * 
     * @param key a key object.
     * @return InputLocation
     */
    public InputLocation getLocation( Object key ) {
        if (key instanceof String && key.equals("")) {
            return this.location;
        }
        return getOtherLocation(key);
    } //-- InputLocation getLocation( Object )

    /**
     * 
     * 
     * @return Map
     */
    public java.util.Map<Object, InputLocation> getLocations()
    {
        return locations;
    } //-- java.util.Map<Object, InputLocation> getLocations()

    /**
     * 
     * 
     * @param key a key object.
     * @param location a location object.
     */
    public void setLocation( Object key, InputLocation location ) {
        if (key instanceof String && key.equals("")) {
            this.location = location;
            return;
        }
        setOtherLocation(key, location);
    } //-- void setLocation( Object, InputLocation )

    /**
     * 
     * 
     * @param key a key object.
     * @param location a location object.
     */
    public void setOtherLocation( Object key, InputLocation location )
    {
        if ( location != null )
        {
            if ( this.locations == null )
            {
                this.locations = new java.util.LinkedHashMap<>();
            }
            this.locations.put( key, location );
        }
    } //-- void setOtherLocation( Object, InputLocation )

    /**
     * 
     * 
     * @param key a key object.
     * @return InputLocation
     */
    private InputLocation getOtherLocation( Object key )
    {
        return ( locations != null ) ? locations.get( key ) : null;
    } //-- InputLocation getOtherLocation( Object )

    /**
     * Get the source field.
     * 
     * @return InputSource
     */
    public InputSource getSource()
    {
        return this.source;
    } //-- InputSource getSource()

    /**
     * Method merge.
     * 
     * @param target a target object.
     * @param sourceDominant a sourceDominant object.
     * @param source a source object.
     * @return InputLocation
     */
    public static InputLocation merge( InputLocation target, InputLocation source, boolean sourceDominant )
    {
        if ( source == null )
        {
            return target;
        }
        else if ( target == null )
        {
            return source;
        }

        InputLocation result =
            new InputLocation( target.getLineNumber(), target.getColumnNumber(), target.getSource() );

        java.util.Map<Object, InputLocation> locations;
        java.util.Map<Object, InputLocation> sourceLocations = source.getLocations();
        java.util.Map<Object, InputLocation> targetLocations = target.getLocations();
        if ( sourceLocations == null )
        {
            locations = targetLocations;
        }
        else if ( targetLocations == null )
        {
            locations = sourceLocations;
        }
        else
        {
            locations = new java.util.LinkedHashMap<>();
            locations.putAll( sourceDominant ? targetLocations : sourceLocations );
            locations.putAll( sourceDominant ? sourceLocations : targetLocations );
        }
        result.setLocations( locations );

        return result;
    } //-- InputLocation merge( InputLocation, InputLocation, boolean )

    /**
     * Method merge.
     * 
     * @param target a target object.
     * @param indices a indices object.
     * @param source a source object.
     * @return InputLocation
     */
    public static InputLocation merge( InputLocation target, InputLocation source, java.util.Collection<Integer> indices )
    {
        if ( source == null )
        {
            return target;
        }
        else if ( target == null )
        {
            return source;
        }

        InputLocation result =
            new InputLocation( target.getLineNumber(), target.getColumnNumber(), target.getSource() );

        java.util.Map<Object, InputLocation> locations;
        java.util.Map<Object, InputLocation> sourceLocations = source.getLocations();
        java.util.Map<Object, InputLocation> targetLocations = target.getLocations();
        if ( sourceLocations == null )
        {
            locations = targetLocations;
        }
        else if ( targetLocations == null )
        {
            locations = sourceLocations;
        }
        else
        {
            locations = new java.util.LinkedHashMap<>();
            for (Integer integer : indices) {
                InputLocation location;
                if (integer < 0) {
                    location = sourceLocations.get(~integer);
                } else {
                    location = targetLocations.get(integer);
                }
                locations.put(locations.size(), location);
            }
        }
        result.setLocations( locations );

        return result;
    } //-- InputLocation merge( InputLocation, InputLocation, java.util.Collection )

    /**
     * 
     * 
     * @param locations a locations object.
     */
    public void setLocations( java.util.Map<Object, InputLocation> locations )
    {
        this.locations = locations;
    } //-- void setLocations( java.util.Map )


      //-----------------/
     //- Inner Classes -/
    //-----------------/

    @Override
    public String toString()
    {
        return getLineNumber() + " : " + getColumnNumber() + ", " + getSource();
    }

}
