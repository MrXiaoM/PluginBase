// =================== DO NOT EDIT THIS FILE ====================
// Generated by Modello 2.1.2,
// any modifications will be overwritten.
// ==============================================================

package top.mrxiaom.pluginbase.resolver.maven.model.io.xpp3;

  //---------------------------------/
 //- Imported classes and packages -/
//---------------------------------/

import org.codehaus.plexus.util.ReaderFactory;
import org.codehaus.plexus.util.xml.pull.EntityReplacementMap;
import org.codehaus.plexus.util.xml.pull.MXParser;
import org.codehaus.plexus.util.xml.pull.XmlPullParser;
import org.codehaus.plexus.util.xml.pull.XmlPullParserException;
import org.jetbrains.annotations.Nullable;
import top.mrxiaom.pluginbase.resolver.maven.model.*;

import java.io.IOException;
import java.io.InputStream;
import java.io.Reader;

/**
 * Class MavenXpp3ReaderEx.
 * 
 * @version $Revision$ $Date$
 */
public class MavenXpp3ReaderEx
{

      //----------------/
     //- Constructors -/
    //----------------/

    public MavenXpp3ReaderEx() {}
      //-----------/
     //- Methods -/
    //-----------/

    /**
     * Method checkFieldWithDuplicate.
     * 
     * @param parser a parser object.
     * @param parsed a parsed object.
     * @param alias a alias object.
     * @param tagName a tagName object.
     * @throws XmlPullParserException XmlPullParserException if
     * any.
     * @return boolean
     */
    private boolean checkFieldWithDuplicate( XmlPullParser parser, String tagName, String alias, java.util.Set<String> parsed )
        throws XmlPullParserException
    {
        if ( !( parser.getName().equals( tagName ) || parser.getName().equals( alias ) ) )
        {
            return false;
        }
        if ( !parsed.add( tagName ) )
        {
            throw new XmlPullParserException( "Duplicated tag: '" + tagName + "'", parser, null );
        }
        return true;
    } //-- boolean checkFieldWithDuplicate( XmlPullParser, String, String, java.util.Set )

    /**
     * Method checkUnknownAttribute.
     * 
     * @param parser a parser object.
     * @param strict a strict object.
     * @param tagName a tagName object.
     * @param attribute a attribute object.
     * @throws XmlPullParserException XmlPullParserException if
     * any.
     */
    private void checkUnknownAttribute( XmlPullParser parser, String attribute, String tagName, boolean strict )
        throws XmlPullParserException {
        // strictXmlAttributes = true for model: if strict == true, not only elements are checked but attributes too
        if ( strict )
        {
            throw new XmlPullParserException( "Unknown attribute '" + attribute + "' for tag '" + tagName + "'", parser, null );
        }
    } //-- void checkUnknownAttribute( XmlPullParser, String, String, boolean )

    /**
     * Method checkUnknownElement.
     * 
     * @param parser a parser object.
     * @param strict a strict object.
     * @throws XmlPullParserException XmlPullParserException if
     * any.
     * @throws IOException IOException if any.
     */
    private void checkUnknownElement( XmlPullParser parser, boolean strict )
        throws XmlPullParserException, IOException
    {
        if ( strict )
        {
            throw new XmlPullParserException( "Unrecognised tag: '" + parser.getName() + "'", parser, null );
        }

        for ( int unrecognizedTagCount = 1; unrecognizedTagCount > 0; )
        {
            int eventType = parser.next();
            if ( eventType == XmlPullParser.START_TAG )
            {
                unrecognizedTagCount++;
            }
            else if ( eventType == XmlPullParser.END_TAG )
            {
                unrecognizedTagCount--;
            }
        }
    } //-- void checkUnknownElement( XmlPullParser, boolean )

    /**
     * Method getBooleanValue.
     * 
     * @param s a s object.
     * @param defaultValue a defaultValue object.
     * @return boolean
     */
    private boolean getBooleanValue(String s, String defaultValue ) {
        if ( s != null && !s.isEmpty())
        {
            return Boolean.parseBoolean(s);
        }
        if ( defaultValue != null )
        {
            return Boolean.parseBoolean(defaultValue);
        }
        return false;
    } //-- boolean getBooleanValue( String, String, XmlPullParser, String )

    /**
     * Method getTrimmedValue.
     * 
     * @param s a s object.
     * @return String
     */
    private String getTrimmedValue( String s )
    {
        if ( s != null )
        {
            s = s.trim();
        }
        return s;
    } //-- String getTrimmedValue( String )

    /**
     * Method interpolatedTrimmed.
     * 
     * @param value a value object.
     * @return String
     */
    private String interpolatedTrimmed( String value )
    {
        return getTrimmedValue( value );
    } //-- String interpolatedTrimmed( String, String )

    /**
     * Method nextTag.
     * 
     * @param parser a parser object.
     * @throws IOException IOException if any.
     * @throws XmlPullParserException XmlPullParserException if
     * any.
     * @return int
     */
    private int nextTag( XmlPullParser parser )
        throws IOException, XmlPullParserException
    {
        int eventType = parser.next();
        if ( eventType == XmlPullParser.TEXT )
        {
            eventType = parser.next();
        }
        if ( eventType != XmlPullParser.START_TAG && eventType != XmlPullParser.END_TAG )
        {
            throw new XmlPullParserException( "expected START_TAG or END_TAG not " + XmlPullParser.TYPES[eventType], parser, null );
        }
        return eventType;
    } //-- int nextTag( XmlPullParser )

    /**
     * Method read.
     * 
     * @param parser a parser object.
     * @param source a source object.
     * @param strict a strict object.
     * @throws IOException IOException if any.
     * @throws XmlPullParserException XmlPullParserException if
     * any.
     * @return Model
     */
    public Model read(XmlPullParser parser, boolean strict, @Nullable InputSource source )
        throws IOException, XmlPullParserException
    {
        Model model = null;
        int eventType = parser.getEventType();
        boolean parsed = false;
        while ( eventType != XmlPullParser.END_DOCUMENT )
        {
            if ( eventType == XmlPullParser.START_TAG )
            {
                if ( strict && ! "project".equals( parser.getName() ) )
                {
                    throw new XmlPullParserException( "Expected root element 'project' but found '" + parser.getName() + "'", parser, null );
                }
                else if ( parsed )
                {
                    // fallback, already expected a XmlPullParserException due to invalid XML
                    throw new XmlPullParserException( "Duplicated tag: 'project'", parser, null );
                }
                model = parseModel( parser, strict, source );
                model.setModelEncoding( parser.getInputEncoding() );
                parsed = true;
            }
            eventType = parser.next();
        }
        if ( parsed )
        {
            return model;
        }
        throw new XmlPullParserException( "Expected root element 'project' but found no element at all: invalid XML document", parser, null );
    } //-- Model read( XmlPullParser, boolean, InputSource )

    /**
     * @see ReaderFactory#newXmlReader
     * 
     * @param reader a reader object.
     * @param source a source object.
     * @param strict a strict object.
     * @throws IOException IOException if any.
     * @throws XmlPullParserException XmlPullParserException if
     * any.
     * @return Model
     */
    public Model read( Reader reader, boolean strict, @Nullable InputSource source)
        throws IOException, XmlPullParserException
    {
        XmlPullParser parser = new MXParser(EntityReplacementMap.defaultEntityReplacementMap);
        parser.setInput( reader );
        return read( parser, strict, source );
    } //-- Model read( Reader, boolean, InputSource )

    /**
     * Method read.
     * 
     * @param in a in object.
     * @param source a source object.
     * @param strict a strict object.
     * @throws IOException IOException if any.
     * @throws XmlPullParserException XmlPullParserException if
     * any.
     * @return Model
     */
    public Model read( InputStream in, boolean strict, @Nullable InputSource source )
        throws IOException, XmlPullParserException
    {
        return read( ReaderFactory.newXmlReader( in ), strict, source );
    } //-- Model read( InputStream, boolean, InputSource )

    /**
     * Method parseActivation.
     * 
     * @param parser a parser object.
     * @param source a source object.
     * @param strict a strict object.
     * @throws IOException IOException if any.
     * @throws XmlPullParserException XmlPullParserException if
     * any.
     * @return Activation
     */
    private Activation parseActivation( XmlPullParser parser, boolean strict, @Nullable InputSource source )
        throws IOException, XmlPullParserException
    {
        String tagName = parser.getName();
        Activation activation = new Activation();
        if (source != null) {
            InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
            activation.setLocation("", _location);
        }
        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
        {
            String name = parser.getAttributeName( i );

            if ( name.indexOf( ':' ) >= 0 )
            {
                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
            }
            else
            {
                checkUnknownAttribute( parser, name, tagName, strict );
            }
        }
        java.util.Set<String> parsed = new java.util.HashSet<>();
        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
        {
            if ( checkFieldWithDuplicate( parser, "activeByDefault", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    activation.setLocation("activeByDefault", _location);
                }
                activation.setActiveByDefault( getBooleanValue( interpolatedTrimmed( parser.nextText()), "false" ) );
            }
            else if ( checkFieldWithDuplicate( parser, "jdk", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    activation.setLocation("jdk", _location);
                }
                activation.setJdk( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "os", null, parsed ) )
            {
                activation.setOs( parseActivationOS( parser, strict, source ) );
            }
            else if ( checkFieldWithDuplicate( parser, "property", null, parsed ) )
            {
                activation.setProperty( parseActivationProperty( parser, strict, source ) );
            }
            else if ( checkFieldWithDuplicate( parser, "file", null, parsed ) )
            {
                activation.setFile( parseActivationFile( parser, strict, source ) );
            }
            else
            {
                checkUnknownElement( parser, strict );
            }
        }
        return activation;
    } //-- Activation parseActivation( XmlPullParser, boolean, InputSource )

    /**
     * Method parseActivationFile.
     * 
     * @param parser a parser object.
     * @param source a source object.
     * @param strict a strict object.
     * @throws IOException IOException if any.
     * @throws XmlPullParserException XmlPullParserException if
     * any.
     * @return ActivationFile
     */
    private ActivationFile parseActivationFile( XmlPullParser parser, boolean strict, @Nullable InputSource source )
        throws IOException, XmlPullParserException
    {
        String tagName = parser.getName();
        ActivationFile activationFile = new ActivationFile();
        if (source != null) {
            InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
            activationFile.setLocation("", _location);
        }
        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
        {
            String name = parser.getAttributeName( i );

            if ( name.indexOf( ':' ) >= 0 )
            {
                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
            }
            else
            {
                checkUnknownAttribute( parser, name, tagName, strict );
            }
        }
        java.util.Set<String> parsed = new java.util.HashSet<>();
        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
        {
            if ( checkFieldWithDuplicate( parser, "missing", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    activationFile.setLocation("missing", _location);
                }
                activationFile.setMissing( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "exists", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    activationFile.setLocation("exists", _location);
                }
                activationFile.setExists( interpolatedTrimmed( parser.nextText()) );
            }
            else
            {
                checkUnknownElement( parser, strict );
            }
        }
        return activationFile;
    } //-- ActivationFile parseActivationFile( XmlPullParser, boolean, InputSource )

    /**
     * Method parseActivationOS.
     * 
     * @param parser a parser object.
     * @param source a source object.
     * @param strict a strict object.
     * @throws IOException IOException if any.
     * @throws XmlPullParserException XmlPullParserException if
     * any.
     * @return ActivationOS
     */
    private ActivationOS parseActivationOS( XmlPullParser parser, boolean strict, @Nullable InputSource source )
        throws IOException, XmlPullParserException
    {
        String tagName = parser.getName();
        ActivationOS activationOS = new ActivationOS();
        if (source != null) {
            InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
            activationOS.setLocation("", _location);
        }
        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
        {
            String name = parser.getAttributeName( i );

            if ( name.indexOf( ':' ) >= 0 )
            {
                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
            }
            else
            {
                checkUnknownAttribute( parser, name, tagName, strict );
            }
        }
        java.util.Set<String> parsed = new java.util.HashSet<>();
        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
        {
            if ( checkFieldWithDuplicate( parser, "name", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    activationOS.setLocation("name", _location);
                }
                activationOS.setName( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "family", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    activationOS.setLocation("family", _location);
                }
                activationOS.setFamily( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "arch", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    activationOS.setLocation("arch", _location);
                }
                activationOS.setArch( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "version", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    activationOS.setLocation("version", _location);
                }
                activationOS.setVersion( interpolatedTrimmed( parser.nextText()) );
            }
            else
            {
                checkUnknownElement( parser, strict );
            }
        }
        return activationOS;
    } //-- ActivationOS parseActivationOS( XmlPullParser, boolean, InputSource )

    /**
     * Method parseActivationProperty.
     * 
     * @param parser a parser object.
     * @param source a source object.
     * @param strict a strict object.
     * @throws IOException IOException if any.
     * @throws XmlPullParserException XmlPullParserException if
     * any.
     * @return ActivationProperty
     */
    private ActivationProperty parseActivationProperty( XmlPullParser parser, boolean strict, @Nullable InputSource source )
        throws IOException, XmlPullParserException
    {
        String tagName = parser.getName();
        ActivationProperty activationProperty = new ActivationProperty();
        if (source != null) {
            InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
            activationProperty.setLocation("", _location);
        }
        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
        {
            String name = parser.getAttributeName( i );

            if ( name.indexOf( ':' ) >= 0 )
            {
                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
            }
            else
            {
                checkUnknownAttribute( parser, name, tagName, strict );
            }
        }
        java.util.Set<String> parsed = new java.util.HashSet<>();
        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
        {
            if ( checkFieldWithDuplicate( parser, "name", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    activationProperty.setLocation("name", _location);
                }
                activationProperty.setName( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "value", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    activationProperty.setLocation("value", _location);
                }
                activationProperty.setValue( interpolatedTrimmed( parser.nextText()) );
            }
            else
            {
                checkUnknownElement( parser, strict );
            }
        }
        return activationProperty;
    } //-- ActivationProperty parseActivationProperty( XmlPullParser, boolean, InputSource )

    /**
     * Method parseBuild.
     * 
     * @param parser a parser object.
     * @param source a source object.
     * @param strict a strict object.
     * @throws IOException IOException if any.
     * @throws XmlPullParserException XmlPullParserException if
     * any.
     * @return Build
     */
    private Build parseBuild( XmlPullParser parser, boolean strict, @Nullable InputSource source )
        throws IOException, XmlPullParserException
    {
        String tagName = parser.getName();
        Build build = new Build();
        if (source != null) {
            InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
            build.setLocation("", _location);
        }
        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
        {
            String name = parser.getAttributeName( i );

            if ( name.indexOf( ':' ) >= 0 )
            {
                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
            }
            else
            {
                checkUnknownAttribute( parser, name, tagName, strict );
            }
        }
        java.util.Set<String> parsed = new java.util.HashSet<>();
        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
        {
            if ( checkFieldWithDuplicate( parser, "sourceDirectory", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    build.setLocation("sourceDirectory", _location);
                }
                build.setSourceDirectory( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "scriptSourceDirectory", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    build.setLocation("scriptSourceDirectory", _location);
                }
                build.setScriptSourceDirectory( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "testSourceDirectory", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    build.setLocation("testSourceDirectory", _location);
                }
                build.setTestSourceDirectory( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "outputDirectory", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    build.setLocation("outputDirectory", _location);
                }
                build.setOutputDirectory( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "testOutputDirectory", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    build.setLocation("testOutputDirectory", _location);
                }
                build.setTestOutputDirectory( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "extensions", null, parsed ) )
            {
                java.util.List<Extension> extensions = new java.util.ArrayList<>();
                while ( parser.nextTag() == XmlPullParser.START_TAG )
                {
                    if ( "extension".equals( parser.getName() ) )
                    {
                        extensions.add( parseExtension( parser, strict, source ) );
                    }
                    else
                    {
                        checkUnknownElement( parser, strict );
                    }
                }
                build.setExtensions( extensions );
            }
            else if ( checkFieldWithDuplicate( parser, "defaultGoal", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    build.setLocation("defaultGoal", _location);
                }
                build.setDefaultGoal( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "resources", null, parsed ) )
            {
                java.util.List<Resource> resources = new java.util.ArrayList<>();
                while ( parser.nextTag() == XmlPullParser.START_TAG )
                {
                    if ( "resource".equals( parser.getName() ) )
                    {
                        resources.add( parseResource( parser, strict, source ) );
                    }
                    else
                    {
                        checkUnknownElement( parser, strict );
                    }
                }
                build.setResources( resources );
            }
            else if ( checkFieldWithDuplicate( parser, "testResources", null, parsed ) )
            {
                java.util.List<Resource> testResources = new java.util.ArrayList<>();
                while ( parser.nextTag() == XmlPullParser.START_TAG )
                {
                    if ( "testResource".equals( parser.getName() ) )
                    {
                        testResources.add( parseResource( parser, strict, source ) );
                    }
                    else
                    {
                        checkUnknownElement( parser, strict );
                    }
                }
                build.setTestResources( testResources );
            }
            else if ( checkFieldWithDuplicate( parser, "directory", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    build.setLocation("directory", _location);
                }
                build.setDirectory( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "finalName", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    build.setLocation("finalName", _location);
                }
                build.setFinalName( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "filters", null, parsed ) )
            {
                java.util.List<String> filters = new java.util.ArrayList<>();
                InputLocation _locations;
                if (source != null) {
                    _locations = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    build.setLocation("filters", _locations);
                } else {
                    _locations = null;
                }
                while ( parser.nextTag() == XmlPullParser.START_TAG )
                {
                    if ( "filter".equals( parser.getName() ) )
                    {
                        if (source != null) {
                            InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                            _locations.setLocation(filters.size(), _location);
                        }
                        filters.add( interpolatedTrimmed( parser.nextText()) );
                    }
                    else
                    {
                        checkUnknownElement( parser, strict );
                    }
                }
                build.setFilters( filters );
            }
            else if ( checkFieldWithDuplicate( parser, "pluginManagement", null, parsed ) )
            {
                build.setPluginManagement( parsePluginManagement( parser, strict, source ) );
            }
            else if ( checkFieldWithDuplicate( parser, "plugins", null, parsed ) )
            {
                java.util.List<Plugin> plugins = new java.util.ArrayList<>();
                while ( parser.nextTag() == XmlPullParser.START_TAG )
                {
                    if ( "plugin".equals( parser.getName() ) )
                    {
                        plugins.add( parsePlugin( parser, strict, source ) );
                    }
                    else
                    {
                        checkUnknownElement( parser, strict );
                    }
                }
                build.setPlugins( plugins );
            }
            else
            {
                checkUnknownElement( parser, strict );
            }
        }
        return build;
    } //-- Build parseBuild( XmlPullParser, boolean, InputSource )

    /**
     * Method parseBuildBase.
     * 
     * @param parser a parser object.
     * @param source a source object.
     * @param strict a strict object.
     * @throws IOException IOException if any.
     * @throws XmlPullParserException XmlPullParserException if
     * any.
     * @return BuildBase
     */
    private BuildBase parseBuildBase( XmlPullParser parser, boolean strict, @Nullable InputSource source )
        throws IOException, XmlPullParserException
    {
        String tagName = parser.getName();
        BuildBase buildBase = new BuildBase();
        if (source != null) {
            InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
            buildBase.setLocation("", _location);
        }
        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
        {
            String name = parser.getAttributeName( i );

            if ( name.indexOf( ':' ) >= 0 )
            {
                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
            }
            else
            {
                checkUnknownAttribute( parser, name, tagName, strict );
            }
        }
        java.util.Set<String> parsed = new java.util.HashSet<>();
        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
        {
            if ( checkFieldWithDuplicate( parser, "defaultGoal", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    buildBase.setLocation("defaultGoal", _location);
                }
                buildBase.setDefaultGoal( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "resources", null, parsed ) )
            {
                java.util.List<Resource> resources = new java.util.ArrayList<>();
                while ( parser.nextTag() == XmlPullParser.START_TAG )
                {
                    if ( "resource".equals( parser.getName() ) )
                    {
                        resources.add( parseResource( parser, strict, source ) );
                    }
                    else
                    {
                        checkUnknownElement( parser, strict );
                    }
                }
                buildBase.setResources( resources );
            }
            else if ( checkFieldWithDuplicate( parser, "testResources", null, parsed ) )
            {
                java.util.List<Resource> testResources = new java.util.ArrayList<>();
                while ( parser.nextTag() == XmlPullParser.START_TAG )
                {
                    if ( "testResource".equals( parser.getName() ) )
                    {
                        testResources.add( parseResource( parser, strict, source ) );
                    }
                    else
                    {
                        checkUnknownElement( parser, strict );
                    }
                }
                buildBase.setTestResources( testResources );
            }
            else if ( checkFieldWithDuplicate( parser, "directory", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    buildBase.setLocation("directory", _location);
                }
                buildBase.setDirectory( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "finalName", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    buildBase.setLocation("finalName", _location);
                }
                buildBase.setFinalName( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "filters", null, parsed ) )
            {
                java.util.List<String> filters = new java.util.ArrayList<>();
                InputLocation _locations;
                if (source != null) {
                    _locations = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    buildBase.setLocation("filters", _locations);
                } else {
                    _locations = null;
                }
                while ( parser.nextTag() == XmlPullParser.START_TAG )
                {
                    if ( "filter".equals( parser.getName() ) )
                    {
                        if (source != null) {
                            InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                            _locations.setLocation(filters.size(), _location);
                        }
                        filters.add( interpolatedTrimmed( parser.nextText()) );
                    }
                    else
                    {
                        checkUnknownElement( parser, strict );
                    }
                }
                buildBase.setFilters( filters );
            }
            else if ( checkFieldWithDuplicate( parser, "pluginManagement", null, parsed ) )
            {
                buildBase.setPluginManagement( parsePluginManagement( parser, strict, source ) );
            }
            else if ( checkFieldWithDuplicate( parser, "plugins", null, parsed ) )
            {
                java.util.List<Plugin> plugins = new java.util.ArrayList<>();
                while ( parser.nextTag() == XmlPullParser.START_TAG )
                {
                    if ( "plugin".equals( parser.getName() ) )
                    {
                        plugins.add( parsePlugin( parser, strict, source ) );
                    }
                    else
                    {
                        checkUnknownElement( parser, strict );
                    }
                }
                buildBase.setPlugins( plugins );
            }
            else
            {
                checkUnknownElement( parser, strict );
            }
        }
        return buildBase;
    } //-- BuildBase parseBuildBase( XmlPullParser, boolean, InputSource )

    /**
     * Method parseCiManagement.
     * 
     * @param parser a parser object.
     * @param source a source object.
     * @param strict a strict object.
     * @throws IOException IOException if any.
     * @throws XmlPullParserException XmlPullParserException if
     * any.
     * @return CiManagement
     */
    private CiManagement parseCiManagement( XmlPullParser parser, boolean strict, @Nullable InputSource source )
        throws IOException, XmlPullParserException
    {
        String tagName = parser.getName();
        CiManagement ciManagement = new CiManagement();
        if (source != null) {
            InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
            ciManagement.setLocation("", _location);
        }
        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
        {
            String name = parser.getAttributeName( i );

            if ( name.indexOf( ':' ) >= 0 )
            {
                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
            }
            else
            {
                checkUnknownAttribute( parser, name, tagName, strict );
            }
        }
        java.util.Set<String> parsed = new java.util.HashSet<>();
        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
        {
            if ( checkFieldWithDuplicate( parser, "system", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    ciManagement.setLocation("system", _location);
                }
                ciManagement.setSystem( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "url", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    ciManagement.setLocation("url", _location);
                }
                ciManagement.setUrl( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "notifiers", null, parsed ) )
            {
                java.util.List<Notifier> notifiers = new java.util.ArrayList<>();
                while ( parser.nextTag() == XmlPullParser.START_TAG )
                {
                    if ( "notifier".equals( parser.getName() ) )
                    {
                        notifiers.add( parseNotifier( parser, strict, source ) );
                    }
                    else
                    {
                        checkUnknownElement( parser, strict );
                    }
                }
                ciManagement.setNotifiers( notifiers );
            }
            else
            {
                checkUnknownElement( parser, strict );
            }
        }
        return ciManagement;
    } //-- CiManagement parseCiManagement( XmlPullParser, boolean, InputSource )

    /**
     * Method parseContributor.
     * 
     * @param parser a parser object.
     * @param source a source object.
     * @param strict a strict object.
     * @throws IOException IOException if any.
     * @throws XmlPullParserException XmlPullParserException if
     * any.
     * @return Contributor
     */
    private Contributor parseContributor( XmlPullParser parser, boolean strict, @Nullable InputSource source )
        throws IOException, XmlPullParserException
    {
        String tagName = parser.getName();
        Contributor contributor = new Contributor();
        if (source != null) {
            InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
            contributor.setLocation("", _location);
        }
        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
        {
            String name = parser.getAttributeName( i );

            if ( name.indexOf( ':' ) >= 0 )
            {
                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
            }
            else
            {
                checkUnknownAttribute( parser, name, tagName, strict );
            }
        }
        java.util.Set<String> parsed = new java.util.HashSet<>();
        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
        {
            if ( checkFieldWithDuplicate( parser, "name", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    contributor.setLocation("name", _location);
                }
                contributor.setName( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "email", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    contributor.setLocation("email", _location);
                }
                contributor.setEmail( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "url", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    contributor.setLocation("url", _location);
                }
                contributor.setUrl( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "organization", "organisation", parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    contributor.setLocation("organization", _location);
                }
                contributor.setOrganization( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "organizationUrl", "organisationUrl", parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    contributor.setLocation("organizationUrl", _location);
                }
                contributor.setOrganizationUrl( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "roles", null, parsed ) )
            {
                java.util.List<String> roles = new java.util.ArrayList<>();
                InputLocation _locations;
                _locations = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
                contributor.setLocation( "roles", _locations );
                while ( parser.nextTag() == XmlPullParser.START_TAG )
                {
                    if ( "role".equals( parser.getName() ) )
                    {
                        if (source != null) {
                            InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                            _locations.setLocation(roles.size(), _location);
                        }
                        roles.add( interpolatedTrimmed( parser.nextText()) );
                    }
                    else
                    {
                        checkUnknownElement( parser, strict );
                    }
                }
                contributor.setRoles( roles );
            }
            else if ( checkFieldWithDuplicate( parser, "timezone", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    contributor.setLocation("timezone", _location);
                }
                contributor.setTimezone( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "properties", null, parsed ) )
            {
                InputLocation _locations;
                _locations = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
                contributor.setLocation( "properties", _locations );
                while ( parser.nextTag() == XmlPullParser.START_TAG )
                {
                    String key = parser.getName();
                    if (source != null) {
                        InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                        _locations.setLocation(key, _location);
                    }
                    String value = parser.nextText().trim();
                    contributor.addProperty( key, value );
                }
            }
            else
            {
                checkUnknownElement( parser, strict );
            }
        }
        return contributor;
    } //-- Contributor parseContributor( XmlPullParser, boolean, InputSource )

    /**
     * Method parseDependency.
     * 
     * @param parser a parser object.
     * @param source a source object.
     * @param strict a strict object.
     * @throws IOException IOException if any.
     * @throws XmlPullParserException XmlPullParserException if
     * any.
     * @return Dependency
     */
    private Dependency parseDependency( XmlPullParser parser, boolean strict, @Nullable InputSource source )
        throws IOException, XmlPullParserException
    {
        String tagName = parser.getName();
        Dependency dependency = new Dependency();
        if (source != null) {
            InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
            dependency.setLocation("", _location);
        }
        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
        {
            String name = parser.getAttributeName( i );

            if ( name.indexOf( ':' ) >= 0 )
            {
                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
            }
            else
            {
                checkUnknownAttribute( parser, name, tagName, strict );
            }
        }
        java.util.Set<String> parsed = new java.util.HashSet<>();
        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
        {
            if ( checkFieldWithDuplicate( parser, "groupId", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    dependency.setLocation("groupId", _location);
                }
                dependency.setGroupId( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "artifactId", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    dependency.setLocation("artifactId", _location);
                }
                dependency.setArtifactId( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "version", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    dependency.setLocation("version", _location);
                }
                dependency.setVersion( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "type", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    dependency.setLocation("type", _location);
                }
                dependency.setType( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "classifier", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    dependency.setLocation("classifier", _location);
                }
                dependency.setClassifier( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "scope", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    dependency.setLocation("scope", _location);
                }
                dependency.setScope( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "systemPath", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    dependency.setLocation("systemPath", _location);
                }
                dependency.setSystemPath( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "exclusions", null, parsed ) )
            {
                java.util.List<Exclusion> exclusions = new java.util.ArrayList<>();
                while ( parser.nextTag() == XmlPullParser.START_TAG )
                {
                    if ( "exclusion".equals( parser.getName() ) )
                    {
                        exclusions.add( parseExclusion( parser, strict, source ) );
                    }
                    else
                    {
                        checkUnknownElement( parser, strict );
                    }
                }
                dependency.setExclusions( exclusions );
            }
            else if ( checkFieldWithDuplicate( parser, "optional", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    dependency.setLocation("optional", _location);
                }
                dependency.setOptional( interpolatedTrimmed( parser.nextText()) );
            }
            else
            {
                checkUnknownElement( parser, strict );
            }
        }
        return dependency;
    } //-- Dependency parseDependency( XmlPullParser, boolean, InputSource )

    /**
     * Method parseDependencyManagement.
     * 
     * @param parser a parser object.
     * @param source a source object.
     * @param strict a strict object.
     * @throws IOException IOException if any.
     * @throws XmlPullParserException XmlPullParserException if
     * any.
     * @return DependencyManagement
     */
    private DependencyManagement parseDependencyManagement( XmlPullParser parser, boolean strict, @Nullable InputSource source )
        throws IOException, XmlPullParserException
    {
        String tagName = parser.getName();
        DependencyManagement dependencyManagement = new DependencyManagement();
        if (source != null) {
            InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
            dependencyManagement.setLocation("", _location);
        }
        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
        {
            String name = parser.getAttributeName( i );

            if ( name.indexOf( ':' ) >= 0 )
            {
                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
            }
            else
            {
                checkUnknownAttribute( parser, name, tagName, strict );
            }
        }
        java.util.Set<String> parsed = new java.util.HashSet<>();
        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
        {
            if ( checkFieldWithDuplicate( parser, "dependencies", null, parsed ) )
            {
                java.util.List<Dependency> dependencies = new java.util.ArrayList<>();
                while ( parser.nextTag() == XmlPullParser.START_TAG )
                {
                    if ( "dependency".equals( parser.getName() ) )
                    {
                        dependencies.add( parseDependency( parser, strict, source ) );
                    }
                    else
                    {
                        checkUnknownElement( parser, strict );
                    }
                }
                dependencyManagement.setDependencies( dependencies );
            }
            else
            {
                checkUnknownElement( parser, strict );
            }
        }
        return dependencyManagement;
    } //-- DependencyManagement parseDependencyManagement( XmlPullParser, boolean, InputSource )

    /**
     * Method parseDeploymentRepository.
     * 
     * @param parser a parser object.
     * @param source a source object.
     * @param strict a strict object.
     * @throws IOException IOException if any.
     * @throws XmlPullParserException XmlPullParserException if
     * any.
     * @return DeploymentRepository
     */
    private DeploymentRepository parseDeploymentRepository( XmlPullParser parser, boolean strict, @Nullable InputSource source )
        throws IOException, XmlPullParserException
    {
        String tagName = parser.getName();
        DeploymentRepository deploymentRepository = new DeploymentRepository();
        if (source != null) {
            InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
            deploymentRepository.setLocation("", _location);
        }
        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
        {
            String name = parser.getAttributeName( i );

            if ( name.indexOf( ':' ) >= 0 )
            {
                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
            }
            else
            {
                checkUnknownAttribute( parser, name, tagName, strict );
            }
        }
        java.util.Set<String> parsed = new java.util.HashSet<>();
        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
        {
            if ( checkFieldWithDuplicate( parser, "uniqueVersion", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    deploymentRepository.setLocation("uniqueVersion", _location);
                }
                deploymentRepository.setUniqueVersion( getBooleanValue( interpolatedTrimmed( parser.nextText()), "true" ) );
            }
            else if ( checkFieldWithDuplicate( parser, "releases", null, parsed ) )
            {
                deploymentRepository.setReleases( parseRepositoryPolicy( parser, strict, source ) );
            }
            else if ( checkFieldWithDuplicate( parser, "snapshots", null, parsed ) )
            {
                deploymentRepository.setSnapshots( parseRepositoryPolicy( parser, strict, source ) );
            }
            else if ( checkFieldWithDuplicate( parser, "id", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    deploymentRepository.setLocation("id", _location);
                }
                deploymentRepository.setId( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "name", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    deploymentRepository.setLocation("name", _location);
                }
                deploymentRepository.setName( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "url", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    deploymentRepository.setLocation("url", _location);
                }
                deploymentRepository.setUrl( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "layout", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    deploymentRepository.setLocation("layout", _location);
                }
                deploymentRepository.setLayout( interpolatedTrimmed( parser.nextText()) );
            }
            else
            {
                checkUnknownElement( parser, strict );
            }
        }
        return deploymentRepository;
    } //-- DeploymentRepository parseDeploymentRepository( XmlPullParser, boolean, InputSource )

    /**
     * Method parseDeveloper.
     * 
     * @param parser a parser object.
     * @param source a source object.
     * @param strict a strict object.
     * @throws IOException IOException if any.
     * @throws XmlPullParserException XmlPullParserException if
     * any.
     * @return Developer
     */
    private Developer parseDeveloper( XmlPullParser parser, boolean strict, @Nullable InputSource source )
        throws IOException, XmlPullParserException
    {
        String tagName = parser.getName();
        Developer developer = new Developer();
        if (source != null) {
            InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
            developer.setLocation("", _location);
        }
        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
        {
            String name = parser.getAttributeName( i );

            if ( name.indexOf( ':' ) >= 0 )
            {
                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
            }
            else
            {
                checkUnknownAttribute( parser, name, tagName, strict );
            }
        }
        java.util.Set<String> parsed = new java.util.HashSet<>();
        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
        {
            if ( checkFieldWithDuplicate( parser, "id", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    developer.setLocation("id", _location);
                }
                developer.setId( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "name", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    developer.setLocation("name", _location);
                }
                developer.setName( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "email", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    developer.setLocation("email", _location);
                }
                developer.setEmail( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "url", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    developer.setLocation("url", _location);
                }
                developer.setUrl( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "organization", "organisation", parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    developer.setLocation("organization", _location);
                }
                developer.setOrganization( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "organizationUrl", "organisationUrl", parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    developer.setLocation("organizationUrl", _location);
                }
                developer.setOrganizationUrl( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "roles", null, parsed ) )
            {
                java.util.List<String> roles = new java.util.ArrayList<>();
                InputLocation _locations;
                _locations = new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), source );
                developer.setLocation( "roles", _locations );
                while ( parser.nextTag() == XmlPullParser.START_TAG )
                {
                    if ( "role".equals( parser.getName() ) )
                    {
                        if (source != null) {
                            InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                            _locations.setLocation(roles.size(), _location);
                        }
                        roles.add( interpolatedTrimmed( parser.nextText()) );
                    }
                    else
                    {
                        checkUnknownElement( parser, strict );
                    }
                }
                developer.setRoles( roles );
            }
            else if ( checkFieldWithDuplicate( parser, "timezone", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    developer.setLocation("timezone", _location);
                }
                developer.setTimezone( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "properties", null, parsed ) )
            {
                InputLocation _locations;
                if (source != null) {
                    _locations = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    developer.setLocation("properties", _locations);
                } else {
                    _locations = null;
                }
                while ( parser.nextTag() == XmlPullParser.START_TAG )
                {
                    String key = parser.getName();
                    if (source != null) {
                        InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                        _locations.setLocation(key, _location);
                    }
                    String value = parser.nextText().trim();
                    developer.addProperty( key, value );
                }
            }
            else
            {
                checkUnknownElement( parser, strict );
            }
        }
        return developer;
    } //-- Developer parseDeveloper( XmlPullParser, boolean, InputSource )

    /**
     * Method parseDistributionManagement.
     * 
     * @param parser a parser object.
     * @param source a source object.
     * @param strict a strict object.
     * @throws IOException IOException if any.
     * @throws XmlPullParserException XmlPullParserException if
     * any.
     * @return DistributionManagement
     */
    private DistributionManagement parseDistributionManagement( XmlPullParser parser, boolean strict, @Nullable InputSource source )
        throws IOException, XmlPullParserException
    {
        String tagName = parser.getName();
        DistributionManagement distributionManagement = new DistributionManagement();
        if (source != null) {
            InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
            distributionManagement.setLocation("", _location);
        }
        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
        {
            String name = parser.getAttributeName( i );

            if ( name.indexOf( ':' ) >= 0 )
            {
                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
            }
            else
            {
                checkUnknownAttribute( parser, name, tagName, strict );
            }
        }
        java.util.Set<String> parsed = new java.util.HashSet<>();
        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
        {
            if ( checkFieldWithDuplicate( parser, "repository", null, parsed ) )
            {
                distributionManagement.setRepository( parseDeploymentRepository( parser, strict, source ) );
            }
            else if ( checkFieldWithDuplicate( parser, "snapshotRepository", null, parsed ) )
            {
                distributionManagement.setSnapshotRepository( parseDeploymentRepository( parser, strict, source ) );
            }
            else if ( checkFieldWithDuplicate( parser, "site", null, parsed ) )
            {
                distributionManagement.setSite( parseSite( parser, strict, source ) );
            }
            else if ( checkFieldWithDuplicate( parser, "downloadUrl", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    distributionManagement.setLocation("downloadUrl", _location);
                }
                distributionManagement.setDownloadUrl( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "relocation", null, parsed ) )
            {
                distributionManagement.setRelocation( parseRelocation( parser, strict, source ) );
            }
            else if ( checkFieldWithDuplicate( parser, "status", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    distributionManagement.setLocation("status", _location);
                }
                distributionManagement.setStatus( interpolatedTrimmed( parser.nextText()) );
            }
            else
            {
                checkUnknownElement( parser, strict );
            }
        }
        return distributionManagement;
    } //-- DistributionManagement parseDistributionManagement( XmlPullParser, boolean, InputSource )

    /**
     * Method parseExclusion.
     * 
     * @param parser a parser object.
     * @param source a source object.
     * @param strict a strict object.
     * @throws IOException IOException if any.
     * @throws XmlPullParserException XmlPullParserException if
     * any.
     * @return Exclusion
     */
    private Exclusion parseExclusion( XmlPullParser parser, boolean strict, @Nullable InputSource source )
        throws IOException, XmlPullParserException
    {
        String tagName = parser.getName();
        Exclusion exclusion = new Exclusion();
        if (source != null) {
            InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
            exclusion.setLocation("", _location);
        }
        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
        {
            String name = parser.getAttributeName( i );

            if ( name.indexOf( ':' ) >= 0 )
            {
                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
            }
            else
            {
                checkUnknownAttribute( parser, name, tagName, strict );
            }
        }
        java.util.Set<String> parsed = new java.util.HashSet<>();
        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
        {
            if ( checkFieldWithDuplicate( parser, "groupId", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    exclusion.setLocation("groupId", _location);
                }
                exclusion.setGroupId( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "artifactId", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    exclusion.setLocation("artifactId", _location);
                }
                exclusion.setArtifactId( interpolatedTrimmed( parser.nextText()) );
            }
            else
            {
                checkUnknownElement( parser, strict );
            }
        }
        return exclusion;
    } //-- Exclusion parseExclusion( XmlPullParser, boolean, InputSource )

    /**
     * Method parseExtension.
     * 
     * @param parser a parser object.
     * @param source a source object.
     * @param strict a strict object.
     * @throws IOException IOException if any.
     * @throws XmlPullParserException XmlPullParserException if
     * any.
     * @return Extension
     */
    private Extension parseExtension( XmlPullParser parser, boolean strict, @Nullable InputSource source )
        throws IOException, XmlPullParserException
    {
        String tagName = parser.getName();
        Extension extension = new Extension();
        if (source != null) {
            InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
            extension.setLocation("", _location);
        }
        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
        {
            String name = parser.getAttributeName( i );

            if ( name.indexOf( ':' ) >= 0 )
            {
                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
            }
            else
            {
                checkUnknownAttribute( parser, name, tagName, strict );
            }
        }
        java.util.Set<String> parsed = new java.util.HashSet<>();
        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
        {
            if ( checkFieldWithDuplicate( parser, "groupId", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    extension.setLocation("groupId", _location);
                }
                extension.setGroupId( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "artifactId", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    extension.setLocation("artifactId", _location);
                }
                extension.setArtifactId( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "version", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    extension.setLocation("version", _location);
                }
                extension.setVersion( interpolatedTrimmed( parser.nextText()) );
            }
            else
            {
                checkUnknownElement( parser, strict );
            }
        }
        return extension;
    } //-- Extension parseExtension( XmlPullParser, boolean, InputSource )

    /**
     * Method parseIssueManagement.
     * 
     * @param parser a parser object.
     * @param source a source object.
     * @param strict a strict object.
     * @throws IOException IOException if any.
     * @throws XmlPullParserException XmlPullParserException if
     * any.
     * @return IssueManagement
     */
    private IssueManagement parseIssueManagement( XmlPullParser parser, boolean strict, @Nullable InputSource source )
        throws IOException, XmlPullParserException
    {
        String tagName = parser.getName();
        IssueManagement issueManagement = new IssueManagement();
        if (source != null) {
            InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
            issueManagement.setLocation("", _location);
        }
        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
        {
            String name = parser.getAttributeName( i );

            if ( name.indexOf( ':' ) >= 0 )
            {
                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
            }
            else
            {
                checkUnknownAttribute( parser, name, tagName, strict );
            }
        }
        java.util.Set<String> parsed = new java.util.HashSet<>();
        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
        {
            if ( checkFieldWithDuplicate( parser, "system", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    issueManagement.setLocation("system", _location);
                }
                issueManagement.setSystem( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "url", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    issueManagement.setLocation("url", _location);
                }
                issueManagement.setUrl( interpolatedTrimmed( parser.nextText()) );
            }
            else
            {
                checkUnknownElement( parser, strict );
            }
        }
        return issueManagement;
    } //-- IssueManagement parseIssueManagement( XmlPullParser, boolean, InputSource )

    /**
     * Method parseLicense.
     * 
     * @param parser a parser object.
     * @param source a source object.
     * @param strict a strict object.
     * @throws IOException IOException if any.
     * @throws XmlPullParserException XmlPullParserException if
     * any.
     * @return License
     */
    private License parseLicense( XmlPullParser parser, boolean strict, @Nullable InputSource source )
        throws IOException, XmlPullParserException
    {
        String tagName = parser.getName();
        License license = new License();
        if (source != null) {
            InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
            license.setLocation("", _location);
        }
        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
        {
            String name = parser.getAttributeName( i );

            if ( name.indexOf( ':' ) >= 0 )
            {
                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
            }
            else
            {
                checkUnknownAttribute( parser, name, tagName, strict );
            }
        }
        java.util.Set<String> parsed = new java.util.HashSet<>();
        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
        {
            if ( checkFieldWithDuplicate( parser, "name", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    license.setLocation("name", _location);
                }
                license.setName( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "url", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    license.setLocation("url", _location);
                }
                license.setUrl( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "distribution", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    license.setLocation("distribution", _location);
                }
                license.setDistribution( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "comments", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    license.setLocation("comments", _location);
                }
                license.setComments( interpolatedTrimmed( parser.nextText()) );
            }
            else
            {
                checkUnknownElement( parser, strict );
            }
        }
        return license;
    } //-- License parseLicense( XmlPullParser, boolean, InputSource )

    /**
     * Method parseMailingList.
     * 
     * @param parser a parser object.
     * @param source a source object.
     * @param strict a strict object.
     * @throws IOException IOException if any.
     * @throws XmlPullParserException XmlPullParserException if
     * any.
     * @return MailingList
     */
    private MailingList parseMailingList( XmlPullParser parser, boolean strict, @Nullable InputSource source )
        throws IOException, XmlPullParserException
    {
        String tagName = parser.getName();
        MailingList mailingList = new MailingList();
        if (source != null) {
            InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
            mailingList.setLocation("", _location);
        }
        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
        {
            String name = parser.getAttributeName( i );

            if ( name.indexOf( ':' ) >= 0 )
            {
                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
            }
            else
            {
                checkUnknownAttribute( parser, name, tagName, strict );
            }
        }
        java.util.Set<String> parsed = new java.util.HashSet<>();
        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
        {
            if ( checkFieldWithDuplicate( parser, "name", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    mailingList.setLocation("name", _location);
                }
                mailingList.setName( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "subscribe", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    mailingList.setLocation("subscribe", _location);
                }
                mailingList.setSubscribe( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "unsubscribe", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    mailingList.setLocation("unsubscribe", _location);
                }
                mailingList.setUnsubscribe( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "post", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    mailingList.setLocation("post", _location);
                }
                mailingList.setPost( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "archive", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    mailingList.setLocation("archive", _location);
                }
                mailingList.setArchive( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "otherArchives", null, parsed ) )
            {
                java.util.List<String> otherArchives = new java.util.ArrayList<>();
                InputLocation _locations;
                if (source != null) {
                    _locations = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    mailingList.setLocation("otherArchives", _locations);
                } else {
                    _locations = null;
                }
                while ( parser.nextTag() == XmlPullParser.START_TAG )
                {
                    if ( "otherArchive".equals( parser.getName() ) )
                    {
                        if (source != null) {
                            InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                            _locations.setLocation(otherArchives.size(), _location);
                        }
                        otherArchives.add( interpolatedTrimmed( parser.nextText()) );
                    }
                    else
                    {
                        checkUnknownElement( parser, strict );
                    }
                }
                mailingList.setOtherArchives( otherArchives );
            }
            else
            {
                checkUnknownElement( parser, strict );
            }
        }
        return mailingList;
    } //-- MailingList parseMailingList( XmlPullParser, boolean, InputSource )

    /**
     * Method parseModel.
     * 
     * @param parser a parser object.
     * @param source a source object.
     * @param strict a strict object.
     * @throws IOException IOException if any.
     * @throws XmlPullParserException XmlPullParserException if
     * any.
     * @return Model
     */
    private Model parseModel( XmlPullParser parser, boolean strict, @Nullable InputSource source )
        throws IOException, XmlPullParserException
    {
        String tagName = parser.getName();
        Model model = new Model();
        if (source != null) {
            InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
            model.setLocation("", _location);
        }
        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
        {
            String name = parser.getAttributeName( i );
            String value = parser.getAttributeValue( i );

            if ( name.indexOf( ':' ) >= 0 )
            {
                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
            }
            else if ( "xmlns".equals( name ) )
            {
                // ignore xmlns attribute in root class, which is a reserved attribute name
            }
            else if ( "child.project.url.inherit.append.path".equals( name ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    model.setLocation("childProjectUrlInheritAppendPath", _location);
                }
                model.setChildProjectUrlInheritAppendPath( interpolatedTrimmed( value) );
            }
            else
            {
                checkUnknownAttribute( parser, name, tagName, strict );
            }
        }
        java.util.Set<String> parsed = new java.util.HashSet<>();
        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
        {
            if ( checkFieldWithDuplicate( parser, "modelVersion", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    model.setLocation("modelVersion", _location);
                }
                model.setModelVersion( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "parent", null, parsed ) )
            {
                model.setParent( parseParent( parser, strict, source ) );
            }
            else if ( checkFieldWithDuplicate( parser, "groupId", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    model.setLocation("groupId", _location);
                }
                model.setGroupId( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "artifactId", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    model.setLocation("artifactId", _location);
                }
                model.setArtifactId( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "version", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    model.setLocation("version", _location);
                }
                model.setVersion( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "packaging", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    model.setLocation("packaging", _location);
                }
                model.setPackaging( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "name", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    model.setLocation("name", _location);
                }
                model.setName( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "description", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    model.setLocation("description", _location);
                }
                model.setDescription( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "url", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    model.setLocation("url", _location);
                }
                model.setUrl( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "inceptionYear", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    model.setLocation("inceptionYear", _location);
                }
                model.setInceptionYear( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "organization", "organisation", parsed ) )
            {
                model.setOrganization( parseOrganization( parser, strict, source ) );
            }
            else if ( checkFieldWithDuplicate( parser, "licenses", null, parsed ) )
            {
                java.util.List<License> licenses = new java.util.ArrayList<>();
                while ( parser.nextTag() == XmlPullParser.START_TAG )
                {
                    if ( "license".equals( parser.getName() ) )
                    {
                        licenses.add( parseLicense( parser, strict, source ) );
                    }
                    else
                    {
                        checkUnknownElement( parser, strict );
                    }
                }
                model.setLicenses( licenses );
            }
            else if ( checkFieldWithDuplicate( parser, "developers", null, parsed ) )
            {
                java.util.List<Developer> developers = new java.util.ArrayList<>();
                while ( parser.nextTag() == XmlPullParser.START_TAG )
                {
                    if ( "developer".equals( parser.getName() ) )
                    {
                        developers.add( parseDeveloper( parser, strict, source ) );
                    }
                    else
                    {
                        checkUnknownElement( parser, strict );
                    }
                }
                model.setDevelopers( developers );
            }
            else if ( checkFieldWithDuplicate( parser, "contributors", null, parsed ) )
            {
                java.util.List<Contributor> contributors = new java.util.ArrayList<>();
                while ( parser.nextTag() == XmlPullParser.START_TAG )
                {
                    if ( "contributor".equals( parser.getName() ) )
                    {
                        contributors.add( parseContributor( parser, strict, source ) );
                    }
                    else
                    {
                        checkUnknownElement( parser, strict );
                    }
                }
                model.setContributors( contributors );
            }
            else if ( checkFieldWithDuplicate( parser, "mailingLists", null, parsed ) )
            {
                java.util.List<MailingList> mailingLists = new java.util.ArrayList<>();
                while ( parser.nextTag() == XmlPullParser.START_TAG )
                {
                    if ( "mailingList".equals( parser.getName() ) )
                    {
                        mailingLists.add( parseMailingList( parser, strict, source ) );
                    }
                    else
                    {
                        checkUnknownElement( parser, strict );
                    }
                }
                model.setMailingLists( mailingLists );
            }
            else if ( checkFieldWithDuplicate( parser, "prerequisites", null, parsed ) )
            {
                model.setPrerequisites( parsePrerequisites( parser, strict, source ) );
            }
            else if ( checkFieldWithDuplicate( parser, "modules", null, parsed ) )
            {
                java.util.List<String> modules = new java.util.ArrayList<>();
                InputLocation _locations;
                if (source != null) {
                    _locations = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    model.setLocation("modules", _locations);
                } else {
                    _locations = null;
                }
                while ( parser.nextTag() == XmlPullParser.START_TAG )
                {
                    if ( "module".equals( parser.getName() ) )
                    {
                        if (source != null) {
                            InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                            _locations.setLocation(modules.size(), _location);
                        }
                        modules.add( interpolatedTrimmed( parser.nextText()) );
                    }
                    else
                    {
                        checkUnknownElement( parser, strict );
                    }
                }
                model.setModules( modules );
            }
            else if ( checkFieldWithDuplicate( parser, "scm", null, parsed ) )
            {
                model.setScm( parseScm( parser, strict, source ) );
            }
            else if ( checkFieldWithDuplicate( parser, "issueManagement", null, parsed ) )
            {
                model.setIssueManagement( parseIssueManagement( parser, strict, source ) );
            }
            else if ( checkFieldWithDuplicate( parser, "ciManagement", null, parsed ) )
            {
                model.setCiManagement( parseCiManagement( parser, strict, source ) );
            }
            else if ( checkFieldWithDuplicate( parser, "distributionManagement", null, parsed ) )
            {
                model.setDistributionManagement( parseDistributionManagement( parser, strict, source ) );
            }
            else if ( checkFieldWithDuplicate( parser, "properties", null, parsed ) )
            {
                InputLocation _locations;
                if (source != null) {
                    _locations = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    model.setLocation("properties", _locations);
                } else {
                    _locations = null;
                }
                while ( parser.nextTag() == XmlPullParser.START_TAG )
                {
                    String key = parser.getName();
                    if (source != null) {
                        InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                        _locations.setLocation(key, _location);
                    }
                    String value = parser.nextText().trim();
                    model.addProperty( key, value );
                }
            }
            else if ( checkFieldWithDuplicate( parser, "dependencyManagement", null, parsed ) )
            {
                model.setDependencyManagement( parseDependencyManagement( parser, strict, source ) );
            }
            else if ( checkFieldWithDuplicate( parser, "dependencies", null, parsed ) )
            {
                java.util.List<Dependency> dependencies = new java.util.ArrayList<>();
                while ( parser.nextTag() == XmlPullParser.START_TAG )
                {
                    if ( "dependency".equals( parser.getName() ) )
                    {
                        dependencies.add( parseDependency( parser, strict, source ) );
                    }
                    else
                    {
                        checkUnknownElement( parser, strict );
                    }
                }
                model.setDependencies( dependencies );
            }
            else if ( checkFieldWithDuplicate( parser, "repositories", null, parsed ) )
            {
                java.util.List<Repository> repositories = new java.util.ArrayList<>();
                while ( parser.nextTag() == XmlPullParser.START_TAG )
                {
                    if ( "repository".equals( parser.getName() ) )
                    {
                        repositories.add( parseRepository( parser, strict, source ) );
                    }
                    else
                    {
                        checkUnknownElement( parser, strict );
                    }
                }
                model.setRepositories( repositories );
            }
            else if ( checkFieldWithDuplicate( parser, "pluginRepositories", null, parsed ) )
            {
                java.util.List<Repository> pluginRepositories = new java.util.ArrayList<>();
                while ( parser.nextTag() == XmlPullParser.START_TAG )
                {
                    if ( "pluginRepository".equals( parser.getName() ) )
                    {
                        pluginRepositories.add( parseRepository( parser, strict, source ) );
                    }
                    else
                    {
                        checkUnknownElement( parser, strict );
                    }
                }
                model.setPluginRepositories( pluginRepositories );
            }
            else if ( checkFieldWithDuplicate( parser, "build", null, parsed ) )
            {
                model.setBuild( parseBuild( parser, strict, source ) );
            }
            else if ( checkFieldWithDuplicate( parser, "reports", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    model.setLocation("reports", _location);
                    model.setReports( org.codehaus.plexus.util.xml.Xpp3DomBuilder.build( parser, true, new Xpp3DomBuilderInputLocationBuilder( _location ) ) );
                } else {
                    model.setReports( org.codehaus.plexus.util.xml.Xpp3DomBuilder.build(parser, true) );
                }
            }
            else if ( checkFieldWithDuplicate( parser, "reporting", null, parsed ) )
            {
                model.setReporting( parseReporting( parser, strict, source ) );
            }
            else if ( checkFieldWithDuplicate( parser, "profiles", null, parsed ) )
            {
                java.util.List<Profile> profiles = new java.util.ArrayList<>();
                while ( parser.nextTag() == XmlPullParser.START_TAG )
                {
                    if ( "profile".equals( parser.getName() ) )
                    {
                        profiles.add( parseProfile( parser, strict, source ) );
                    }
                    else
                    {
                        checkUnknownElement( parser, strict );
                    }
                }
                model.setProfiles( profiles );
            }
            else
            {
                checkUnknownElement( parser, strict );
            }
        }
        return model;
    } //-- Model parseModel( XmlPullParser, boolean, InputSource )

    /**
     * Method parseNotifier.
     * 
     * @param parser a parser object.
     * @param source a source object.
     * @param strict a strict object.
     * @throws IOException IOException if any.
     * @throws XmlPullParserException XmlPullParserException if
     * any.
     * @return Notifier
     */
    private Notifier parseNotifier( XmlPullParser parser, boolean strict, @Nullable InputSource source )
        throws IOException, XmlPullParserException
    {
        String tagName = parser.getName();
        Notifier notifier = new Notifier();
        if (source != null) {
            InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
            notifier.setLocation("", _location);
        }
        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
        {
            String name = parser.getAttributeName( i );

            if ( name.indexOf( ':' ) >= 0 )
            {
                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
            }
            else
            {
                checkUnknownAttribute( parser, name, tagName, strict );
            }
        }
        java.util.Set<String> parsed = new java.util.HashSet<>();
        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
        {
            if ( checkFieldWithDuplicate( parser, "type", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    notifier.setLocation("type", _location);
                }
                notifier.setType( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "sendOnError", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    notifier.setLocation("sendOnError", _location);
                }
                notifier.setSendOnError( getBooleanValue( interpolatedTrimmed( parser.nextText()), "true" ) );
            }
            else if ( checkFieldWithDuplicate( parser, "sendOnFailure", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    notifier.setLocation("sendOnFailure", _location);
                }
                notifier.setSendOnFailure( getBooleanValue( interpolatedTrimmed( parser.nextText()), "true" ) );
            }
            else if ( checkFieldWithDuplicate( parser, "sendOnSuccess", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    notifier.setLocation("sendOnSuccess", _location);
                }
                notifier.setSendOnSuccess( getBooleanValue( interpolatedTrimmed( parser.nextText()), "true" ) );
            }
            else if ( checkFieldWithDuplicate( parser, "sendOnWarning", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    notifier.setLocation("sendOnWarning", _location);
                }
                notifier.setSendOnWarning( getBooleanValue( interpolatedTrimmed( parser.nextText()), "true" ) );
            }
            else if ( checkFieldWithDuplicate( parser, "address", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    notifier.setLocation("address", _location);
                }
                notifier.setAddress( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "configuration", null, parsed ) )
            {
                InputLocation _locations;
                if (source != null) {
                    _locations = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    notifier.setLocation("configuration", _locations);
                } else {
                    _locations = null;
                }
                while ( parser.nextTag() == XmlPullParser.START_TAG )
                {
                    String key = parser.getName();
                    if (source != null) {
                        InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                        _locations.setLocation(key, _location);
                    }
                    String value = parser.nextText().trim();
                    notifier.addConfiguration( key, value );
                }
            }
            else
            {
                checkUnknownElement( parser, strict );
            }
        }
        return notifier;
    } //-- Notifier parseNotifier( XmlPullParser, boolean, InputSource )

    /**
     * Method parseOrganization.
     * 
     * @param parser a parser object.
     * @param source a source object.
     * @param strict a strict object.
     * @throws IOException IOException if any.
     * @throws XmlPullParserException XmlPullParserException if
     * any.
     * @return Organization
     */
    private Organization parseOrganization( XmlPullParser parser, boolean strict, @Nullable InputSource source )
        throws IOException, XmlPullParserException
    {
        String tagName = parser.getName();
        Organization organization = new Organization();
        if (source != null) {
            InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
            organization.setLocation("", _location);
        }
        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
        {
            String name = parser.getAttributeName( i );

            if ( name.indexOf( ':' ) >= 0 )
            {
                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
            }
            else
            {
                checkUnknownAttribute( parser, name, tagName, strict );
            }
        }
        java.util.Set<String> parsed = new java.util.HashSet<>();
        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
        {
            if ( checkFieldWithDuplicate( parser, "name", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    organization.setLocation("name", _location);
                }
                organization.setName( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "url", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    organization.setLocation("url", _location);
                }
                organization.setUrl( interpolatedTrimmed( parser.nextText()) );
            }
            else
            {
                checkUnknownElement( parser, strict );
            }
        }
        return organization;
    } //-- Organization parseOrganization( XmlPullParser, boolean, InputSource )

    /**
     * Method parseParent.
     * 
     * @param parser a parser object.
     * @param source a source object.
     * @param strict a strict object.
     * @throws IOException IOException if any.
     * @throws XmlPullParserException XmlPullParserException if
     * any.
     * @return Parent
     */
    private Parent parseParent( XmlPullParser parser, boolean strict, @Nullable InputSource source )
        throws IOException, XmlPullParserException
    {
        String tagName = parser.getName();
        Parent parent = new Parent();
        if (source != null) {
            InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
            parent.setLocation("", _location);
        }
        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
        {
            String name = parser.getAttributeName( i );

            if ( name.indexOf( ':' ) >= 0 )
            {
                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
            }
            else
            {
                checkUnknownAttribute( parser, name, tagName, strict );
            }
        }
        java.util.Set<String> parsed = new java.util.HashSet<>();
        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
        {
            if ( checkFieldWithDuplicate( parser, "groupId", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    parent.setLocation("groupId", _location);
                }
                parent.setGroupId( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "artifactId", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    parent.setLocation("artifactId", _location);
                }
                parent.setArtifactId( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "version", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    parent.setLocation("version", _location);
                }
                parent.setVersion( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "relativePath", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    parent.setLocation("relativePath", _location);
                }
                parent.setRelativePath( interpolatedTrimmed( parser.nextText()) );
            }
            else
            {
                checkUnknownElement( parser, strict );
            }
        }
        return parent;
    } //-- Parent parseParent( XmlPullParser, boolean, InputSource )

    /**
     * Method parsePlugin.
     * 
     * @param parser a parser object.
     * @param source a source object.
     * @param strict a strict object.
     * @throws IOException IOException if any.
     * @throws XmlPullParserException XmlPullParserException if
     * any.
     * @return Plugin
     */
    private Plugin parsePlugin( XmlPullParser parser, boolean strict, @Nullable InputSource source )
        throws IOException, XmlPullParserException
    {
        String tagName = parser.getName();
        Plugin plugin = new Plugin();
        if (source != null) {
            InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
            plugin.setLocation("", _location);
        }
        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
        {
            String name = parser.getAttributeName( i );

            if ( name.indexOf( ':' ) >= 0 )
            {
                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
            }
            else
            {
                checkUnknownAttribute( parser, name, tagName, strict );
            }
        }
        java.util.Set<String> parsed = new java.util.HashSet<>();
        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
        {
            if ( checkFieldWithDuplicate( parser, "groupId", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    plugin.setLocation("groupId", _location);
                }
                plugin.setGroupId( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "artifactId", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    plugin.setLocation("artifactId", _location);
                }
                plugin.setArtifactId( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "version", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    plugin.setLocation("version", _location);
                }
                plugin.setVersion( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "extensions", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    plugin.setLocation("extensions", _location);
                }
                plugin.setExtensions( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "executions", null, parsed ) )
            {
                java.util.List<PluginExecution> executions = new java.util.ArrayList<>();
                while ( parser.nextTag() == XmlPullParser.START_TAG )
                {
                    if ( "execution".equals( parser.getName() ) )
                    {
                        executions.add( parsePluginExecution( parser, strict, source ) );
                    }
                    else
                    {
                        checkUnknownElement( parser, strict );
                    }
                }
                plugin.setExecutions( executions );
            }
            else if ( checkFieldWithDuplicate( parser, "dependencies", null, parsed ) )
            {
                java.util.List<Dependency> dependencies = new java.util.ArrayList<>();
                while ( parser.nextTag() == XmlPullParser.START_TAG )
                {
                    if ( "dependency".equals( parser.getName() ) )
                    {
                        dependencies.add( parseDependency( parser, strict, source ) );
                    }
                    else
                    {
                        checkUnknownElement( parser, strict );
                    }
                }
                plugin.setDependencies( dependencies );
            }
            else if ( checkFieldWithDuplicate( parser, "goals", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    plugin.setLocation("goals", _location);
                    plugin.setGoals(org.codehaus.plexus.util.xml.Xpp3DomBuilder.build(parser, true, new Xpp3DomBuilderInputLocationBuilder(_location)));
                } else {
                    plugin.setGoals(org.codehaus.plexus.util.xml.Xpp3DomBuilder.build(parser, true));
                }
            }
            else if ( checkFieldWithDuplicate( parser, "inherited", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    plugin.setLocation("inherited", _location);
                }
                plugin.setInherited( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "configuration", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    plugin.setLocation("configuration", _location);
                    plugin.setConfiguration(org.codehaus.plexus.util.xml.Xpp3DomBuilder.build(parser, true, new Xpp3DomBuilderInputLocationBuilder(_location)));
                } else {
                    plugin.setConfiguration(org.codehaus.plexus.util.xml.Xpp3DomBuilder.build(parser, true));
                }
            }
            else
            {
                checkUnknownElement( parser, strict );
            }
        }
        return plugin;
    } //-- Plugin parsePlugin( XmlPullParser, boolean, InputSource )

    /**
     * Method parsePluginExecution.
     * 
     * @param parser a parser object.
     * @param source a source object.
     * @param strict a strict object.
     * @throws IOException IOException if any.
     * @throws XmlPullParserException XmlPullParserException if
     * any.
     * @return PluginExecution
     */
    private PluginExecution parsePluginExecution( XmlPullParser parser, boolean strict, @Nullable InputSource source )
        throws IOException, XmlPullParserException
    {
        String tagName = parser.getName();
        PluginExecution pluginExecution = new PluginExecution();
        if (source != null) {
            InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
            pluginExecution.setLocation("", _location);
        }
        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
        {
            String name = parser.getAttributeName( i );

            if ( name.indexOf( ':' ) >= 0 )
            {
                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
            }
            else
            {
                checkUnknownAttribute( parser, name, tagName, strict );
            }
        }
        java.util.Set<String> parsed = new java.util.HashSet<>();
        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
        {
            if ( checkFieldWithDuplicate( parser, "id", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    pluginExecution.setLocation("id", _location);
                }
                pluginExecution.setId( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "phase", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    pluginExecution.setLocation("phase", _location);
                }
                pluginExecution.setPhase( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "goals", null, parsed ) )
            {
                java.util.List<String> goals = new java.util.ArrayList<>();
                InputLocation _locations;
                if (source != null) {
                    _locations = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    pluginExecution.setLocation("goals", _locations);
                } else {
                    _locations = null;
                }
                while ( parser.nextTag() == XmlPullParser.START_TAG )
                {
                    if ( "goal".equals( parser.getName() ) )
                    {
                        if (source != null) {
                            InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                            _locations.setLocation(goals.size(), _location);
                        }
                        goals.add( interpolatedTrimmed( parser.nextText()) );
                    }
                    else
                    {
                        checkUnknownElement( parser, strict );
                    }
                }
                pluginExecution.setGoals( goals );
            }
            else if ( checkFieldWithDuplicate( parser, "inherited", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    pluginExecution.setLocation("inherited", _location);
                }
                pluginExecution.setInherited( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "configuration", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    pluginExecution.setLocation("configuration", _location);
                    pluginExecution.setConfiguration(org.codehaus.plexus.util.xml.Xpp3DomBuilder.build(parser, true, new Xpp3DomBuilderInputLocationBuilder(_location)));
                } else {
                    pluginExecution.setConfiguration(org.codehaus.plexus.util.xml.Xpp3DomBuilder.build(parser, true));
                }
            }
            else
            {
                checkUnknownElement( parser, strict );
            }
        }
        return pluginExecution;
    } //-- PluginExecution parsePluginExecution( XmlPullParser, boolean, InputSource )

    /**
     * Method parsePluginManagement.
     * 
     * @param parser a parser object.
     * @param source a source object.
     * @param strict a strict object.
     * @throws IOException IOException if any.
     * @throws XmlPullParserException XmlPullParserException if
     * any.
     * @return PluginManagement
     */
    private PluginManagement parsePluginManagement( XmlPullParser parser, boolean strict, @Nullable InputSource source )
        throws IOException, XmlPullParserException
    {
        String tagName = parser.getName();
        PluginManagement pluginManagement = new PluginManagement();
        if (source != null) {
            InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
            pluginManagement.setLocation("", _location);
        }
        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
        {
            String name = parser.getAttributeName( i );

            if ( name.indexOf( ':' ) >= 0 )
            {
                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
            }
            else
            {
                checkUnknownAttribute( parser, name, tagName, strict );
            }
        }
        java.util.Set<String> parsed = new java.util.HashSet<>();
        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
        {
            if ( checkFieldWithDuplicate( parser, "plugins", null, parsed ) )
            {
                java.util.List<Plugin> plugins = new java.util.ArrayList<>();
                while ( parser.nextTag() == XmlPullParser.START_TAG )
                {
                    if ( "plugin".equals( parser.getName() ) )
                    {
                        plugins.add( parsePlugin( parser, strict, source ) );
                    }
                    else
                    {
                        checkUnknownElement( parser, strict );
                    }
                }
                pluginManagement.setPlugins( plugins );
            }
            else
            {
                checkUnknownElement( parser, strict );
            }
        }
        return pluginManagement;
    } //-- PluginManagement parsePluginManagement( XmlPullParser, boolean, InputSource )

    /**
     * Method parsePrerequisites.
     * 
     * @param parser a parser object.
     * @param source a source object.
     * @param strict a strict object.
     * @throws IOException IOException if any.
     * @throws XmlPullParserException XmlPullParserException if
     * any.
     * @return Prerequisites
     */
    private Prerequisites parsePrerequisites( XmlPullParser parser, boolean strict, @Nullable InputSource source )
        throws IOException, XmlPullParserException
    {
        String tagName = parser.getName();
        Prerequisites prerequisites = new Prerequisites();
        if (source != null) {
            InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
            prerequisites.setLocation("", _location);
        }
        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
        {
            String name = parser.getAttributeName( i );

            if ( name.indexOf( ':' ) >= 0 )
            {
                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
            }
            else
            {
                checkUnknownAttribute( parser, name, tagName, strict );
            }
        }
        java.util.Set<String> parsed = new java.util.HashSet<>();
        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
        {
            if ( checkFieldWithDuplicate( parser, "maven", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    prerequisites.setLocation("maven", _location);
                }
                prerequisites.setMaven( interpolatedTrimmed( parser.nextText()) );
            }
            else
            {
                checkUnknownElement( parser, strict );
            }
        }
        return prerequisites;
    } //-- Prerequisites parsePrerequisites( XmlPullParser, boolean, InputSource )

    /**
     * Method parseProfile.
     * 
     * @param parser a parser object.
     * @param source a source object.
     * @param strict a strict object.
     * @throws IOException IOException if any.
     * @throws XmlPullParserException XmlPullParserException if
     * any.
     * @return Profile
     */
    private Profile parseProfile( XmlPullParser parser, boolean strict, @Nullable InputSource source )
        throws IOException, XmlPullParserException
    {
        String tagName = parser.getName();
        Profile profile = new Profile();
        if (source != null) {
            InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
            profile.setLocation("", _location);
        }
        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
        {
            String name = parser.getAttributeName( i );

            if ( name.indexOf( ':' ) >= 0 )
            {
                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
            }
            else
            {
                checkUnknownAttribute( parser, name, tagName, strict );
            }
        }
        java.util.Set<String> parsed = new java.util.HashSet<>();
        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
        {
            if ( checkFieldWithDuplicate( parser, "id", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    profile.setLocation("id", _location);
                }
                profile.setId( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "activation", null, parsed ) )
            {
                profile.setActivation( parseActivation( parser, strict, source ) );
            }
            else if ( checkFieldWithDuplicate( parser, "build", null, parsed ) )
            {
                profile.setBuild( parseBuildBase( parser, strict, source ) );
            }
            else if ( checkFieldWithDuplicate( parser, "modules", null, parsed ) )
            {
                java.util.List<String> modules = new java.util.ArrayList<>();
                InputLocation _locations;
                if (source != null) {
                    _locations = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    profile.setLocation("modules", _locations);
                } else {
                    _locations = null;
                }
                while ( parser.nextTag() == XmlPullParser.START_TAG )
                {
                    if ( "module".equals( parser.getName() ) )
                    {
                        if (source != null) {
                            InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                            _locations.setLocation(modules.size(), _location);
                        }
                        modules.add( interpolatedTrimmed( parser.nextText()) );
                    }
                    else
                    {
                        checkUnknownElement( parser, strict );
                    }
                }
                profile.setModules( modules );
            }
            else if ( checkFieldWithDuplicate( parser, "distributionManagement", null, parsed ) )
            {
                profile.setDistributionManagement( parseDistributionManagement( parser, strict, source ) );
            }
            else if ( checkFieldWithDuplicate( parser, "properties", null, parsed ) )
            {
                InputLocation _locations;
                if (source != null) {
                    _locations = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    profile.setLocation("properties", _locations);
                } else {
                    _locations = null;
                }
                while ( parser.nextTag() == XmlPullParser.START_TAG )
                {
                    String key = parser.getName();
                    if (source != null) {
                        InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                        _locations.setLocation(key, _location);
                    }
                    String value = parser.nextText().trim();
                    profile.addProperty( key, value );
                }
            }
            else if ( checkFieldWithDuplicate( parser, "dependencyManagement", null, parsed ) )
            {
                profile.setDependencyManagement( parseDependencyManagement( parser, strict, source ) );
            }
            else if ( checkFieldWithDuplicate( parser, "dependencies", null, parsed ) )
            {
                java.util.List<Dependency> dependencies = new java.util.ArrayList<>();
                while ( parser.nextTag() == XmlPullParser.START_TAG )
                {
                    if ( "dependency".equals( parser.getName() ) )
                    {
                        dependencies.add( parseDependency( parser, strict, source ) );
                    }
                    else
                    {
                        checkUnknownElement( parser, strict );
                    }
                }
                profile.setDependencies( dependencies );
            }
            else if ( checkFieldWithDuplicate( parser, "repositories", null, parsed ) )
            {
                java.util.List<Repository> repositories = new java.util.ArrayList<>();
                while ( parser.nextTag() == XmlPullParser.START_TAG )
                {
                    if ( "repository".equals( parser.getName() ) )
                    {
                        repositories.add( parseRepository( parser, strict, source ) );
                    }
                    else
                    {
                        checkUnknownElement( parser, strict );
                    }
                }
                profile.setRepositories( repositories );
            }
            else if ( checkFieldWithDuplicate( parser, "pluginRepositories", null, parsed ) )
            {
                java.util.List<Repository> pluginRepositories = new java.util.ArrayList<>();
                while ( parser.nextTag() == XmlPullParser.START_TAG )
                {
                    if ( "pluginRepository".equals( parser.getName() ) )
                    {
                        pluginRepositories.add( parseRepository( parser, strict, source ) );
                    }
                    else
                    {
                        checkUnknownElement( parser, strict );
                    }
                }
                profile.setPluginRepositories( pluginRepositories );
            }
            else if ( checkFieldWithDuplicate( parser, "reports", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    profile.setLocation("reports", _location);
                    profile.setReports(org.codehaus.plexus.util.xml.Xpp3DomBuilder.build(parser, true, new Xpp3DomBuilderInputLocationBuilder(_location)));
                } else {
                    profile.setReports(org.codehaus.plexus.util.xml.Xpp3DomBuilder.build(parser, true));
                }
            }
            else if ( checkFieldWithDuplicate( parser, "reporting", null, parsed ) )
            {
                profile.setReporting( parseReporting( parser, strict, source ) );
            }
            else
            {
                checkUnknownElement( parser, strict );
            }
        }
        return profile;
    } //-- Profile parseProfile( XmlPullParser, boolean, InputSource )

    /**
     * Method parseRelocation.
     * 
     * @param parser a parser object.
     * @param source a source object.
     * @param strict a strict object.
     * @throws IOException IOException if any.
     * @throws XmlPullParserException XmlPullParserException if
     * any.
     * @return Relocation
     */
    private Relocation parseRelocation( XmlPullParser parser, boolean strict, @Nullable InputSource source )
        throws IOException, XmlPullParserException
    {
        String tagName = parser.getName();
        Relocation relocation = new Relocation();
        if (source != null) {
            InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
            relocation.setLocation("", _location);
        }
        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
        {
            String name = parser.getAttributeName( i );

            if ( name.indexOf( ':' ) >= 0 )
            {
                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
            }
            else
            {
                checkUnknownAttribute( parser, name, tagName, strict );
            }
        }
        java.util.Set<String> parsed = new java.util.HashSet<>();
        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
        {
            if ( checkFieldWithDuplicate( parser, "groupId", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    relocation.setLocation("groupId", _location);
                }
                relocation.setGroupId( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "artifactId", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    relocation.setLocation("artifactId", _location);
                }
                relocation.setArtifactId( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "version", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    relocation.setLocation("version", _location);
                }
                relocation.setVersion( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "message", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    relocation.setLocation("message", _location);
                }
                relocation.setMessage( interpolatedTrimmed( parser.nextText()) );
            }
            else
            {
                checkUnknownElement( parser, strict );
            }
        }
        return relocation;
    } //-- Relocation parseRelocation( XmlPullParser, boolean, InputSource )

    /**
     * Method parseReportPlugin.
     * 
     * @param parser a parser object.
     * @param source a source object.
     * @param strict a strict object.
     * @throws IOException IOException if any.
     * @throws XmlPullParserException XmlPullParserException if
     * any.
     * @return ReportPlugin
     */
    private ReportPlugin parseReportPlugin( XmlPullParser parser, boolean strict, @Nullable InputSource source )
        throws IOException, XmlPullParserException
    {
        String tagName = parser.getName();
        ReportPlugin reportPlugin = new ReportPlugin();
        if (source != null) {
            InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
            reportPlugin.setLocation("", _location);
        }
        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
        {
            String name = parser.getAttributeName( i );

            if ( name.indexOf( ':' ) >= 0 )
            {
                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
            }
            else
            {
                checkUnknownAttribute( parser, name, tagName, strict );
            }
        }
        java.util.Set<String> parsed = new java.util.HashSet<>();
        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
        {
            if ( checkFieldWithDuplicate( parser, "groupId", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    reportPlugin.setLocation("groupId", _location);
                }
                reportPlugin.setGroupId( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "artifactId", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    reportPlugin.setLocation("artifactId", _location);
                }
                reportPlugin.setArtifactId( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "version", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    reportPlugin.setLocation("version", _location);
                }
                reportPlugin.setVersion( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "reportSets", null, parsed ) )
            {
                java.util.List<ReportSet> reportSets = new java.util.ArrayList<>();
                while ( parser.nextTag() == XmlPullParser.START_TAG )
                {
                    if ( "reportSet".equals( parser.getName() ) )
                    {
                        reportSets.add( parseReportSet( parser, strict, source ) );
                    }
                    else
                    {
                        checkUnknownElement( parser, strict );
                    }
                }
                reportPlugin.setReportSets( reportSets );
            }
            else if ( checkFieldWithDuplicate( parser, "inherited", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    reportPlugin.setLocation("inherited", _location);
                }
                reportPlugin.setInherited( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "configuration", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    reportPlugin.setLocation("configuration", _location);
                    reportPlugin.setConfiguration(org.codehaus.plexus.util.xml.Xpp3DomBuilder.build(parser, true, new Xpp3DomBuilderInputLocationBuilder(_location)));
                } else {
                    reportPlugin.setConfiguration(org.codehaus.plexus.util.xml.Xpp3DomBuilder.build(parser, true));
                }
            }
            else
            {
                checkUnknownElement( parser, strict );
            }
        }
        return reportPlugin;
    } //-- ReportPlugin parseReportPlugin( XmlPullParser, boolean, InputSource )

    /**
     * Method parseReportSet.
     * 
     * @param parser a parser object.
     * @param source a source object.
     * @param strict a strict object.
     * @throws IOException IOException if any.
     * @throws XmlPullParserException XmlPullParserException if
     * any.
     * @return ReportSet
     */
    private ReportSet parseReportSet( XmlPullParser parser, boolean strict, @Nullable InputSource source )
        throws IOException, XmlPullParserException
    {
        String tagName = parser.getName();
        ReportSet reportSet = new ReportSet();
        if (source != null) {
            InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
            reportSet.setLocation("", _location);
        }
        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
        {
            String name = parser.getAttributeName( i );

            if ( name.indexOf( ':' ) >= 0 )
            {
                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
            }
            else
            {
                checkUnknownAttribute( parser, name, tagName, strict );
            }
        }
        java.util.Set<String> parsed = new java.util.HashSet<>();
        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
        {
            if ( checkFieldWithDuplicate( parser, "id", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    reportSet.setLocation("id", _location);
                }
                reportSet.setId( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "reports", null, parsed ) )
            {
                java.util.List<String> reports = new java.util.ArrayList<>();
                InputLocation _locations;
                if (source != null) {
                    _locations = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    reportSet.setLocation("reports", _locations);
                } else {
                    _locations = null;
                }
                while ( parser.nextTag() == XmlPullParser.START_TAG )
                {
                    if ( "report".equals( parser.getName() ) )
                    {
                        if (source != null) {
                            InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                            _locations.setLocation(reports.size(), _location);
                        }
                        reports.add( interpolatedTrimmed( parser.nextText()) );
                    }
                    else
                    {
                        checkUnknownElement( parser, strict );
                    }
                }
                reportSet.setReports( reports );
            }
            else if ( checkFieldWithDuplicate( parser, "inherited", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    reportSet.setLocation("inherited", _location);
                }
                reportSet.setInherited( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "configuration", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    reportSet.setLocation("configuration", _location);
                    reportSet.setConfiguration(org.codehaus.plexus.util.xml.Xpp3DomBuilder.build(parser, true, new Xpp3DomBuilderInputLocationBuilder(_location)));
                } else {
                    reportSet.setConfiguration(org.codehaus.plexus.util.xml.Xpp3DomBuilder.build(parser, true));
                }
            }
            else
            {
                checkUnknownElement( parser, strict );
            }
        }
        return reportSet;
    } //-- ReportSet parseReportSet( XmlPullParser, boolean, InputSource )

    /**
     * Method parseReporting.
     * 
     * @param parser a parser object.
     * @param source a source object.
     * @param strict a strict object.
     * @throws IOException IOException if any.
     * @throws XmlPullParserException XmlPullParserException if
     * any.
     * @return Reporting
     */
    private Reporting parseReporting( XmlPullParser parser, boolean strict, @Nullable InputSource source )
        throws IOException, XmlPullParserException
    {
        String tagName = parser.getName();
        Reporting reporting = new Reporting();
        if (source != null) {
            InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
            reporting.setLocation("", _location);
        }
        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
        {
            String name = parser.getAttributeName( i );

            if ( name.indexOf( ':' ) >= 0 )
            {
                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
            }
            else
            {
                checkUnknownAttribute( parser, name, tagName, strict );
            }
        }
        java.util.Set<String> parsed = new java.util.HashSet<>();
        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
        {
            if ( checkFieldWithDuplicate( parser, "excludeDefaults", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    reporting.setLocation("excludeDefaults", _location);
                }
                reporting.setExcludeDefaults( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "outputDirectory", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    reporting.setLocation("outputDirectory", _location);
                }
                reporting.setOutputDirectory( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "plugins", null, parsed ) )
            {
                java.util.List<ReportPlugin> plugins = new java.util.ArrayList<>();
                while ( parser.nextTag() == XmlPullParser.START_TAG )
                {
                    if ( "plugin".equals( parser.getName() ) )
                    {
                        plugins.add( parseReportPlugin( parser, strict, source ) );
                    }
                    else
                    {
                        checkUnknownElement( parser, strict );
                    }
                }
                reporting.setPlugins( plugins );
            }
            else
            {
                checkUnknownElement( parser, strict );
            }
        }
        return reporting;
    } //-- Reporting parseReporting( XmlPullParser, boolean, InputSource )

    /**
     * Method parseRepository.
     * 
     * @param parser a parser object.
     * @param source a source object.
     * @param strict a strict object.
     * @throws IOException IOException if any.
     * @throws XmlPullParserException XmlPullParserException if
     * any.
     * @return Repository
     */
    private Repository parseRepository( XmlPullParser parser, boolean strict, @Nullable InputSource source )
        throws IOException, XmlPullParserException
    {
        String tagName = parser.getName();
        Repository repository = new Repository();
        if (source != null) {
            InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
            repository.setLocation("", _location);
        }
        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
        {
            String name = parser.getAttributeName( i );

            if ( name.indexOf( ':' ) >= 0 )
            {
                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
            }
            else
            {
                checkUnknownAttribute( parser, name, tagName, strict );
            }
        }
        java.util.Set<String> parsed = new java.util.HashSet<>();
        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
        {
            if ( checkFieldWithDuplicate( parser, "releases", null, parsed ) )
            {
                repository.setReleases( parseRepositoryPolicy( parser, strict, source ) );
            }
            else if ( checkFieldWithDuplicate( parser, "snapshots", null, parsed ) )
            {
                repository.setSnapshots( parseRepositoryPolicy( parser, strict, source ) );
            }
            else if ( checkFieldWithDuplicate( parser, "id", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    repository.setLocation("id", _location);
                }
                repository.setId( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "name", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    repository.setLocation("name", _location);
                }
                repository.setName( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "url", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    repository.setLocation("url", _location);
                }
                repository.setUrl( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "layout", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    repository.setLocation("layout", _location);
                }
                repository.setLayout( interpolatedTrimmed( parser.nextText()) );
            }
            else
            {
                checkUnknownElement( parser, strict );
            }
        }
        return repository;
    } //-- Repository parseRepository( XmlPullParser, boolean, InputSource )

    /**
     * Method parseRepositoryPolicy.
     * 
     * @param parser a parser object.
     * @param source a source object.
     * @param strict a strict object.
     * @throws IOException IOException if any.
     * @throws XmlPullParserException XmlPullParserException if
     * any.
     * @return RepositoryPolicy
     */
    private RepositoryPolicy parseRepositoryPolicy( XmlPullParser parser, boolean strict, @Nullable InputSource source )
        throws IOException, XmlPullParserException
    {
        String tagName = parser.getName();
        RepositoryPolicy repositoryPolicy = new RepositoryPolicy();
        if (source != null) {
            InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
            repositoryPolicy.setLocation("", _location);
        }
        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
        {
            String name = parser.getAttributeName( i );

            if ( name.indexOf( ':' ) >= 0 )
            {
                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
            }
            else
            {
                checkUnknownAttribute( parser, name, tagName, strict );
            }
        }
        java.util.Set<String> parsed = new java.util.HashSet<>();
        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
        {
            if ( checkFieldWithDuplicate( parser, "enabled", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    repositoryPolicy.setLocation("enabled", _location);
                }
                repositoryPolicy.setEnabled( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "updatePolicy", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    repositoryPolicy.setLocation("updatePolicy", _location);
                }
                repositoryPolicy.setUpdatePolicy( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "checksumPolicy", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    repositoryPolicy.setLocation("checksumPolicy", _location);
                }
                repositoryPolicy.setChecksumPolicy( interpolatedTrimmed( parser.nextText()) );
            }
            else
            {
                checkUnknownElement( parser, strict );
            }
        }
        return repositoryPolicy;
    } //-- RepositoryPolicy parseRepositoryPolicy( XmlPullParser, boolean, InputSource )

    /**
     * Method parseResource.
     * 
     * @param parser a parser object.
     * @param source a source object.
     * @param strict a strict object.
     * @throws IOException IOException if any.
     * @throws XmlPullParserException XmlPullParserException if
     * any.
     * @return Resource
     */
    private Resource parseResource( XmlPullParser parser, boolean strict, @Nullable InputSource source )
        throws IOException, XmlPullParserException
    {
        String tagName = parser.getName();
        Resource resource = new Resource();
        if (source != null) {
            InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
            resource.setLocation("", _location);
        }
        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
        {
            String name = parser.getAttributeName( i );

            if ( name.indexOf( ':' ) >= 0 )
            {
                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
            }
            else
            {
                checkUnknownAttribute( parser, name, tagName, strict );
            }
        }
        java.util.Set<String> parsed = new java.util.HashSet<>();
        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
        {
            if ( checkFieldWithDuplicate( parser, "targetPath", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    resource.setLocation("targetPath", _location);
                }
                resource.setTargetPath( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "filtering", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    resource.setLocation("filtering", _location);
                }
                resource.setFiltering( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "directory", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    resource.setLocation("directory", _location);
                }
                resource.setDirectory( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "includes", null, parsed ) )
            {
                java.util.List<String> includes = new java.util.ArrayList<>();
                InputLocation _locations;
                if (source != null) {
                    _locations = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    resource.setLocation("includes", _locations);
                } else {
                    _locations = null;
                }
                while ( parser.nextTag() == XmlPullParser.START_TAG )
                {
                    if ( "include".equals( parser.getName() ) )
                    {
                        if (source != null) {
                            InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                            _locations.setLocation(includes.size(), _location);
                        }
                        includes.add( interpolatedTrimmed( parser.nextText()) );
                    }
                    else
                    {
                        checkUnknownElement( parser, strict );
                    }
                }
                resource.setIncludes( includes );
            }
            else if ( checkFieldWithDuplicate( parser, "excludes", null, parsed ) )
            {
                java.util.List<String> excludes = new java.util.ArrayList<>();
                InputLocation _locations;
                if (source != null) {
                    _locations = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    resource.setLocation("excludes", _locations);
                } else {
                    _locations = null;
                }
                while ( parser.nextTag() == XmlPullParser.START_TAG )
                {
                    if ( "exclude".equals( parser.getName() ) )
                    {
                        if (source != null) {
                            InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                            _locations.setLocation(excludes.size(), _location);
                        }
                        excludes.add( interpolatedTrimmed( parser.nextText()) );
                    }
                    else
                    {
                        checkUnknownElement( parser, strict );
                    }
                }
                resource.setExcludes( excludes );
            }
            else
            {
                checkUnknownElement( parser, strict );
            }
        }
        return resource;
    } //-- Resource parseResource( XmlPullParser, boolean, InputSource )

    /**
     * Method parseScm.
     * 
     * @param parser a parser object.
     * @param source a source object.
     * @param strict a strict object.
     * @throws IOException IOException if any.
     * @throws XmlPullParserException XmlPullParserException if
     * any.
     * @return Scm
     */
    private Scm parseScm( XmlPullParser parser, boolean strict, @Nullable InputSource source )
        throws IOException, XmlPullParserException
    {
        String tagName = parser.getName();
        Scm scm = new Scm();
        if (source != null) {
            InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
            scm.setLocation("", _location);
        }
        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
        {
            String name = parser.getAttributeName( i );
            String value = parser.getAttributeValue( i );

            if ( name.indexOf( ':' ) >= 0 )
            {
                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
            }
            else if ( "child.scm.connection.inherit.append.path".equals( name ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    scm.setLocation("childScmConnectionInheritAppendPath", _location);
                }
                scm.setChildScmConnectionInheritAppendPath( interpolatedTrimmed( value) );
            }
            else if ( "child.scm.developerConnection.inherit.append.path".equals( name ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    scm.setLocation("childScmDeveloperConnectionInheritAppendPath", _location);
                }
                scm.setChildScmDeveloperConnectionInheritAppendPath( interpolatedTrimmed( value) );
            }
            else if ( "child.scm.url.inherit.append.path".equals( name ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    scm.setLocation("childScmUrlInheritAppendPath", _location);
                }
                scm.setChildScmUrlInheritAppendPath( interpolatedTrimmed( value) );
            }
            else
            {
                checkUnknownAttribute( parser, name, tagName, strict );
            }
        }
        java.util.Set<String> parsed = new java.util.HashSet<>();
        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
        {
            if ( checkFieldWithDuplicate( parser, "connection", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    scm.setLocation("connection", _location);
                }
                scm.setConnection( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "developerConnection", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    scm.setLocation("developerConnection", _location);
                }
                scm.setDeveloperConnection( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "tag", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    scm.setLocation("tag", _location);
                }
                scm.setTag( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "url", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    scm.setLocation("url", _location);
                }
                scm.setUrl( interpolatedTrimmed( parser.nextText()) );
            }
            else
            {
                checkUnknownElement( parser, strict );
            }
        }
        return scm;
    } //-- Scm parseScm( XmlPullParser, boolean, InputSource )

    /**
     * Method parseSite.
     * 
     * @param parser a parser object.
     * @param source a source object.
     * @param strict a strict object.
     * @throws IOException IOException if any.
     * @throws XmlPullParserException XmlPullParserException if
     * any.
     * @return Site
     */
    private Site parseSite( XmlPullParser parser, boolean strict, @Nullable InputSource source )
        throws IOException, XmlPullParserException
    {
        String tagName = parser.getName();
        Site site = new Site();
        if (source != null) {
            InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
            site.setLocation("", _location);
        }
        for ( int i = parser.getAttributeCount() - 1; i >= 0; i-- )
        {
            String name = parser.getAttributeName( i );
            String value = parser.getAttributeValue( i );

            if ( name.indexOf( ':' ) >= 0 )
            {
                // just ignore attributes with non-default namespace (for example: xmlns:xsi)
            }
            else if ( "child.site.url.inherit.append.path".equals( name ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    site.setLocation("childSiteUrlInheritAppendPath", _location);
                }
                site.setChildSiteUrlInheritAppendPath( interpolatedTrimmed( value) );
            }
            else
            {
                checkUnknownAttribute( parser, name, tagName, strict );
            }
        }
        java.util.Set<String> parsed = new java.util.HashSet<>();
        while ( ( strict ? parser.nextTag() : nextTag( parser ) ) == XmlPullParser.START_TAG )
        {
            if ( checkFieldWithDuplicate( parser, "id", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    site.setLocation("id", _location);
                }
                site.setId( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "name", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    site.setLocation("name", _location);
                }
                site.setName( interpolatedTrimmed( parser.nextText()) );
            }
            else if ( checkFieldWithDuplicate( parser, "url", null, parsed ) )
            {
                if (source != null) {
                    InputLocation _location = new InputLocation(parser.getLineNumber(), parser.getColumnNumber(), source);
                    site.setLocation("url", _location);
                }
                site.setUrl( interpolatedTrimmed( parser.nextText()) );
            }
            else
            {
                checkUnknownElement( parser, strict );
            }
        }
        return site;
    } //-- Site parseSite( XmlPullParser, boolean, InputSource )


      //-----------------/
     //- Inner Classes -/
    //-----------------/

    /**
     * Class Xpp3DomBuilderInputLocationBuilder.
     * 
     * @version $Revision$ $Date$
     */
    private static class Xpp3DomBuilderInputLocationBuilder
        implements org.codehaus.plexus.util.xml.Xpp3DomBuilder.InputLocationBuilder
    {

          //--------------------------/
         //- Class/Member Variables -/
        //--------------------------/

        /**
         * Field rootLocation.
         */
        private final InputLocation rootLocation;


          //----------------/
         //- Constructors -/
        //----------------/

        public Xpp3DomBuilderInputLocationBuilder(InputLocation rootLocation)
        {
            this.rootLocation = rootLocation;
        } //-- org.apache.maven.model.io.xpp3.Xpp3DomBuilderInputLocationBuilder(InputLocation)


          //-----------/
         //- Methods -/
        //-----------/

        /**
         * Method toInputLocation.
         *
         * @param parser a parser object.
         * @return Object
         */
        public Object toInputLocation( XmlPullParser parser )
        {
            return new InputLocation( parser.getLineNumber(), parser.getColumnNumber(), rootLocation.getSource() );
        } //-- Object toInputLocation( XmlPullParser )

    }

}
